import streamlit as st
import time
import base64

# import whisper
import openai
import os
import shutil
from pydub import AudioSegment
from datetime import timedelta, datetime
import tempfile
from dotenv import load_dotenv

# ========== ENV ==========
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = OPENAI_API_KEY

# ========== CONFIG ==========
# MODEL_SIZE = "medium"  # Whisper model size: "tiny", "base", "small", "medium", "large"
CHUNK_DURATION_MINUTES = 2
# ===========================

client = openai.OpenAI(api_key=OPENAI_API_KEY)


def local_font(path: str):
    if not os.path.exists(path):
        # st.error(f"Font file not found: {path}")
        return
    with open(path, "rb") as f:
        font_data = f.read()
    b64_font = base64.b64encode(font_data).decode()
    font_face = f"""
    <style>
    @font-face {{
        font-family: "MyFont";
        src: url(data:font/ttf;base64,{b64_font}) format("truetype");
    }}

    html, body, [class*="st-"] {{
        font-family: "MyFont", sans-serif;
        direction: rtl;
        text-align: right;
    }}
    </style>
    """
    st.markdown(font_face, unsafe_allow_html=True)


def format_time(ms):
    return str(timedelta(milliseconds=ms))


def split_audio(audio, chunk_duration_ms):
    return [
        audio[i : i + chunk_duration_ms]
        for i in range(0, len(audio), chunk_duration_ms)
    ]


def transcribe_audio_via_api(audio_path, prompt, index=None):
    label = f"ÿ®ÿÆÿ¥ {index}" if index is not None else "ŸÅÿß€åŸÑ"
    st.info(f"üîä ÿØÿ± ÿ≠ÿßŸÑ ÿßÿ±ÿ≥ÿßŸÑ {label} ÿ®Ÿá OpenAI gpt-4o-transcribe API...")

    with open(audio_path, "rb") as f:
        transcript = client.audio.transcriptions.create(
            model="gpt-4o-transcribe",
            file=f,
            language="fa",  # Optional, but improves accuracy for Persian
            # prompt='ŸÜÿßŸÖ ÿ¥ÿ±⁄©ÿ™ Ÿáÿß ŸÖÿ´ŸÑ ŸÖ⁄©ÿπÿ®ÿå ŸÜÿßŸÖ ÿßŸÅÿ±ÿßÿØ ŸÖÿßŸÜŸÜÿØ ÿπÿßÿ®ÿØ ŸæŸàÿ±'
            prompt=prompt,
        )

    return transcript.text


def show_logs_ui():
    log_root = os.path.join(os.path.dirname(__file__), "log")
    st.sidebar.title("üìÅ ÿ™ÿßÿ±€åÿÆ⁄ÜŸá Ÿà ŸÑÿß⁄Ø‚ÄåŸáÿß")
    if not os.path.exists(log_root):
        st.sidebar.info("ŸáŸÜŸàÿ≤ ŸÑÿß⁄Ø€å Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        return

    # Get all log folders, sorted by timestamp descending
    log_folders = [
        f for f in os.listdir(log_root)
        if os.path.isdir(os.path.join(log_root, f))
    ]
    if not log_folders:
        st.sidebar.info("ŸáŸÜŸàÿ≤ ŸÑÿß⁄Ø€å Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        return
    log_folders.sort(reverse=True)

    # Show most recent log by default
    selected_log = st.sidebar.selectbox(
        "€å⁄© ŸÑÿß⁄Ø ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", log_folders, format_func=lambda x: x.replace('_', ' ')
    )
    if not selected_log:
        return

    log_dir = os.path.join(log_root, selected_log)
    st.sidebar.markdown(f"**ÿ≤ŸÖÿßŸÜ:** `{selected_log}`")

    # List files in log folder, show text files first, then others
    files = sorted(os.listdir(log_dir), key=lambda x: (not x.endswith('.txt'), x))
    for fname in files:
        file_path = os.path.join(log_dir, fname)
        # Try to read as text, fallback to binary
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            is_text = True
        except Exception:
            with open(file_path, "rb") as f:
                content = f.read()
            is_text = False

        with st.sidebar.expander(fname):
            if is_text:
                st.code(content, language=None)
            else:
                st.write("(ŸÅÿß€åŸÑ ÿ∫€åÿ± ŸÖÿ™ŸÜ€å)")
        st.sidebar.download_button(
            label=f"ÿØÿßŸÜŸÑŸàÿØ {fname}",
            data=content,
            file_name=fname,
            mime="text/plain" if is_text else "application/octet-stream",
        )


def summarize_text(transcript, gpt_prompt):
    st.info("üß† Summarizing the transcription...")
    #     prompt = f"""

    # ÿ®Ÿá ÿµŸàÿ±ÿ™ ŸÖŸÅ€åÿØ Ÿà ÿ¨ÿßŸÖÿπ ÿ®ÿßÿ≤ŸÜŸà€åÿ≥€å Ÿà ÿØÿ± ŸÇÿßŸÑÿ® ÿ≤€åÿ± ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®ÿØŸá
    # €± ŸÖŸàÿ∂Ÿàÿπ ÿµÿ≠ÿ®ÿ™
    # €≤ ÿßÿπÿ∂ÿß€å ÿ≠ÿßÿ∂ÿ± ÿØÿ±  Ÿà€åÿ≥ ÿ®ÿß ÿßÿ≥ŸÖ Ÿà ŸÅÿßŸÖ€åŸÑ
    # €≥ ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ¨ŸÑÿ≥Ÿá ÿØÿ± ÿ≠ÿßŸÑÿ™ ŸÖŸÅ€åÿØ
    # €¥ ÿµÿ≠ÿ®ÿ™ Ÿáÿß€å€å ⁄©Ÿá ÿ®ÿ±ÿß€å ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖŸÅ€åÿØ ÿßÿ≥ÿ™
    # €µ ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ∫€åÿ± ŸÖŸÅ€åÿØ ÿ¨ŸÑÿ≥Ÿá (ÿ≤ŸÖÿßŸÜ Ÿáÿß€å ÿßÿ≥ÿ™ÿ±ÿßÿ≠ÿ™ Ÿà ÿ≥⁄©Ÿàÿ™ )
    # €∂ ÿ≤ŸÖÿßŸÜ ⁄©ŸÑ ÿ¨ŸÑÿ≥Ÿá
    # €∑ ŸÜÿ™€åÿ¨Ÿá ⁄©ŸÑ€å ÿ¨ŸÑÿ≥Ÿá
    # €∏ ÿßÿ≠ÿ≥ÿßÿ≥ÿßÿ™ ÿßŸÅÿ±ÿßÿØ ÿØÿ± ÿßÿ®ÿ™ÿØÿß Ÿà ÿßŸÜÿ™Ÿáÿß€å ÿ¨ŸÑÿ≥Ÿá (ÿ®Ÿá ÿ∑Ÿàÿ± ŸÖŸÇÿßŸÑ ŸÖÿ¥ÿ™ÿ±€å ÿ®ÿß ÿ±ÿ∂ÿß€åÿ™ ÿÆÿØÿßÿ≠ÿßŸÅÿ∏€å ⁄©ÿ±ÿØ ŸÜÿßÿ±ÿßÿ≠ÿ™ €åÿß ÿÆŸÜÿ´€å Ÿà ÿ£€åÿß ÿ™ŸÖÿßŸÖ ÿÆŸàÿßÿ≥ÿ™Ÿá Ÿáÿß ÿ¥ŸÜ€åÿØŸá ÿ¥ÿØ €åÿß ÿÆ€åÿ±)
    # €π ⁄©ÿßÿ±Ÿáÿß€å ÿßÿ±ÿ¨ÿßÿπ ÿ¥ÿØŸá ⁄ÜŸá ÿ®ŸàÿØŸá Ÿà ⁄ÜŸá ⁄©ÿ≥€å ÿ™ÿß ⁄ÜŸá ÿ≤ŸÖÿßŸÜ€å ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØŸáÿü
    # ŸÜ⁄©ÿ™Ÿá : ÿß⁄Øÿ± €å⁄©€å ÿßÿ≤ ŸÖŸàÿßÿ±ÿØ ÿ®ÿßŸÑÿß ÿØÿ± Ÿà€åÿ≥ ŸÖÿ¨ŸáŸàŸÑ ÿ®ŸàÿØ ÿ®ŸÜŸà€åÿ≥ ÿ®Ÿá ÿß€åŸÜ ŸÖŸàÿ∂Ÿàÿπ Ÿæÿ±ÿØÿßÿÆÿ™Ÿá ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™

    # {transcript}
    # """
    prompt = f"""
{gpt_prompt}

{transcript}
"""

    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[
            {
                "role": "system",
                "content": "ÿ™Ÿà €å⁄© ÿØÿ≥ÿ™€åÿßÿ± Ÿáÿ≥ÿ™€å ⁄©Ÿá ŸÖÿ™ŸÜ‚ÄåŸáÿß€å ŸÅÿßÿ±ÿ≥€å ÿ±ÿß ÿÆŸÑÿßÿµŸá ŸÖ€å‚Äå⁄©ŸÜ€å.",
            },
            {"role": "user", "content": prompt},
        ],
    )

    summary = response.choices[0].message.content
    return summary.strip()


# ========== LOGGING ===========
def save_request_log(
    original_file_path,
    original_file_name,
    transcribe_prompt,
    transcript,
    gpt_prompt,
    summary,
    extra_data=None,
):
    log_root = os.path.join(os.path.dirname(__file__), "log")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    log_dir = os.path.join(log_root, timestamp)
    os.makedirs(log_dir, exist_ok=True)

    # Save original file
    if original_file_path and os.path.exists(original_file_path):
        shutil.copy2(
            original_file_path, os.path.join(log_dir, f"original_{original_file_name}")
        )

    # Save transcribe prompt
    with open(
        os.path.join(log_dir, "transcribe_prompt.txt"), "w", encoding="utf-8"
    ) as f:
        f.write(transcribe_prompt or "")

    # Save transcript
    with open(os.path.join(log_dir, "transcript.txt"), "w", encoding="utf-8") as f:
        f.write(transcript or "")

    # Save gpt prompt
    with open(os.path.join(log_dir, "gpt_prompt.txt"), "w", encoding="utf-8") as f:
        f.write(gpt_prompt or "")

    # Save summary
    with open(os.path.join(log_dir, "summary.txt"), "w", encoding="utf-8") as f:
        f.write(summary or "")

    # Save any extra data
    if extra_data:
        for key, value in extra_data.items():
            with open(os.path.join(log_dir, f"{key}.txt"), "w", encoding="utf-8") as f:
                f.write(str(value))

    return log_dir


def main():
    st.set_page_config(
        page_title="Persian Audio Summarizer",
        layout="centered",
    )
    
    # show_logs_ui()

    print("üîµ App started: Setting up font and UI")
    local_font("fonts/IRANSansX-Regular.ttf")

    st.title("üß† Persian Audio Summarizer")
    st.markdown("ÿ¢ŸæŸÑŸàÿØ ŸÅÿß€åŸÑ ÿµŸàÿ™€å ŸÅÿßÿ±ÿ≥€å Ÿà ÿØÿ±€åÿßŸÅÿ™ ÿÆŸÑÿßÿµŸá ÿ¢ŸÜ ÿ®ÿß ⁄©ŸÖ⁄© ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å")

    uploaded_file = st.file_uploader(
        "üéôÔ∏è ŸÅÿß€åŸÑ ÿµŸàÿ™€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ", type=["mp3", "wav", "m4a"]
    )
    print("üü¢ File uploader rendered")

    transcribe_prompt = st.text_input(
        "ÿ±ÿßŸáŸÜŸÖÿß€å€å gpt ÿ®ÿ±ÿß€å ÿ™ÿ¥ÿÆ€åÿµ ÿØÿ±ÿ≥ÿ™ ŸÖÿ™ŸÜ: ",
        " ŸÜÿßŸÖ ÿ¥ÿ±⁄©ÿ™ Ÿáÿß ŸÖÿ´ŸÑ ŸÖ⁄©ÿπÿ®ÿå ŸÜÿßŸÖ ÿßŸÅÿ±ÿßÿØ ŸÖÿßŸÜŸÜÿØ ÿπÿßÿ®ÿØ ŸæŸàÿ± Ÿà ÿ®Ÿáÿ±ÿßŸÖ€å ŸÅÿ±",
    )
    print("üü¢ Transcribe prompt input rendered")

    gpt_prompt = st.text_area(
        "Ÿæÿ±ÿßŸÖŸæÿ™ gpt ÿ¨Ÿáÿ™ ÿÆŸÑÿßÿµŸá ⁄©ÿ±ÿØŸÜ ŸÖÿ™ŸÜ:",
        """ÿ®Ÿá ÿµŸàÿ±ÿ™ ŸÖŸÅ€åÿØ Ÿà ÿ¨ÿßŸÖÿπ ÿ®ÿßÿ≤ŸÜŸà€åÿ≥€å Ÿà ÿØÿ± ŸÇÿßŸÑÿ® ÿ≤€åÿ± ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ®ÿØŸá 
€± ŸÖŸàÿ∂Ÿàÿπ ÿµÿ≠ÿ®ÿ™
€≤ ÿßÿπÿ∂ÿß€å ÿ≠ÿßÿ∂ÿ± ÿØÿ±  Ÿà€åÿ≥ ÿ®ÿß ÿßÿ≥ŸÖ Ÿà ŸÅÿßŸÖ€åŸÑ 
€≥ ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ¨ŸÑÿ≥Ÿá ÿØÿ± ÿ≠ÿßŸÑÿ™ ŸÖŸÅ€åÿØ
€¥ ÿµÿ≠ÿ®ÿ™ Ÿáÿß€å€å ⁄©Ÿá ÿ®ÿ±ÿß€å ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖŸÅ€åÿØ ÿßÿ≥ÿ™
€µ ŸÖÿØÿ™ ÿ≤ŸÖÿßŸÜ ÿ∫€åÿ± ŸÖŸÅ€åÿØ ÿ¨ŸÑÿ≥Ÿá (ÿ≤ŸÖÿßŸÜ Ÿáÿß€å ÿßÿ≥ÿ™ÿ±ÿßÿ≠ÿ™ Ÿà ÿ≥⁄©Ÿàÿ™ )
€∂ ÿ≤ŸÖÿßŸÜ ⁄©ŸÑ ÿ¨ŸÑÿ≥Ÿá
€∑ ŸÜÿ™€åÿ¨Ÿá ⁄©ŸÑ€å ÿ¨ŸÑÿ≥Ÿá
€∏ ÿßÿ≠ÿ≥ÿßÿ≥ÿßÿ™ ÿßŸÅÿ±ÿßÿØ ÿØÿ± ÿßÿ®ÿ™ÿØÿß Ÿà ÿßŸÜÿ™Ÿáÿß€å ÿ¨ŸÑÿ≥Ÿá (ÿ®Ÿá ÿ∑Ÿàÿ± ŸÖŸÇÿßŸÑ ŸÖÿ¥ÿ™ÿ±€å ÿ®ÿß ÿ±ÿ∂ÿß€åÿ™ ÿÆÿØÿßÿ≠ÿßŸÅÿ∏€å ⁄©ÿ±ÿØ ŸÜÿßÿ±ÿßÿ≠ÿ™ €åÿß ÿÆŸÜÿ´€å Ÿà ÿ£€åÿß ÿ™ŸÖÿßŸÖ ÿÆŸàÿßÿ≥ÿ™Ÿá Ÿáÿß ÿ¥ŸÜ€åÿØŸá ÿ¥ÿØ €åÿß ÿÆ€åÿ±)
€π ⁄©ÿßÿ±Ÿáÿß€å ÿßÿ±ÿ¨ÿßÿπ ÿ¥ÿØŸá ⁄ÜŸá ÿ®ŸàÿØŸá Ÿà ⁄ÜŸá ⁄©ÿ≥€å ÿ™ÿß ⁄ÜŸá ÿ≤ŸÖÿßŸÜ€å ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØŸáÿü
ŸÜ⁄©ÿ™Ÿá : ÿß⁄Øÿ± €å⁄©€å ÿßÿ≤ ŸÖŸàÿßÿ±ÿØ ÿ®ÿßŸÑÿß ÿØÿ± Ÿà€åÿ≥ ŸÖÿ¨ŸáŸàŸÑ ÿ®ŸàÿØ ÿ®ŸÜŸà€åÿ≥ ÿ®Ÿá ÿß€åŸÜ ŸÖŸàÿ∂Ÿàÿπ Ÿæÿ±ÿØÿßÿÆÿ™Ÿá ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™

    """,
        height=300,
    )
    print("üü¢ GPT prompt input rendered")

    if uploaded_file is not None:
        print("üü° File uploaded, saving temporarily...")
        with st.spinner("üìÅ ÿØÿ± ÿ≠ÿßŸÑ ÿ∞ÿÆ€åÿ±Ÿá ŸÅÿß€åŸÑ ÿµŸàÿ™€å..."):
            with tempfile.NamedTemporaryFile(
                delete=False, suffix=uploaded_file.name[-4:]
            ) as tmp_file:
                tmp_file.write(uploaded_file.read())
                temp_path = tmp_file.name

        st.success("‚úÖ ŸÅÿß€åŸÑ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ!")
        print(f"‚úÖ File saved at {temp_path}")

        print("üü° Loading and preprocessing audio...")
        with st.spinner("üéöÔ∏è ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ ÿµŸàÿ™€å..."):
            audio = (
                AudioSegment.from_file(temp_path).set_frame_rate(16000).set_channels(1)
            )
        print("‚úÖ Audio loaded and preprocessed")

        chunk_duration_ms = CHUNK_DURATION_MINUTES * 60 * 1000
        if len(audio) > chunk_duration_ms:
            st.info(f"üéß ÿ∑ŸàŸÑ ŸÅÿß€åŸÑ ÿµŸàÿ™€å ÿ≤€åÿßÿØ ÿßÿ≥ÿ™: {format_time(len(audio))}")
            print("üü° Audio is long, splitting into chunks...")
            with st.spinner("‚úÇÔ∏è ÿØÿ± ÿ≠ÿßŸÑ ÿ™ŸÇÿ≥€åŸÖ ŸÅÿß€åŸÑ ÿµŸàÿ™€å ÿ®Ÿá ÿ®ÿÆÿ¥‚ÄåŸáÿß€å ⁄©Ÿà⁄Ü⁄©ÿ™ÿ±..."):
                chunks = split_audio(audio, chunk_duration_ms)
            st.success(f"‚úÖ ŸÅÿß€åŸÑ ÿ®Ÿá {len(chunks)} ÿ®ÿÆÿ¥ ÿ™ŸÇÿ≥€åŸÖ ÿ¥ÿØ.")
            print(f"‚úÖ Audio split into {len(chunks)} chunks")
        else:
            chunks = [audio]
            print("‚úÖ Audio is short, no split needed")

        full_transcript = ""
        progress_bar = st.progress(0, text="üîÑ ÿØÿ± ÿ≠ÿßŸÑ ÿ™ÿ®ÿØ€åŸÑ ÿµŸàÿ™ ÿ®Ÿá ŸÖÿ™ŸÜ...")
        total_seconds = 0
        start_total = time.time()

        for idx, chunk in enumerate(chunks):
            print(f"üü° Processing chunk {idx+1}/{len(chunks)}...")
            with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as temp_chunk:
                chunk.export(temp_chunk.name, format="wav")
                start = time.time()

                with st.spinner(f"üîä ÿ®ÿÆÿ¥ {idx+1} ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿßÿ≥ÿ™..."):
                    text = transcribe_audio_via_api(
                        temp_chunk.name, transcribe_prompt, index=idx + 1
                    )

                end = time.time()
                duration = end - start
                st.success(f"‚è±Ô∏è ÿ®ÿÆÿ¥ {idx+1} ÿØÿ± {duration:.2f} ÿ´ÿßŸÜ€åŸá Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ¥ÿØ")
                print(f"‚úÖ Chunk {idx+1} processed in {duration:.2f} seconds")

                full_transcript += text + "\n"
                total_seconds += len(chunk) / 1000  # ms to sec
                os.remove(temp_chunk.name)

            progress = int(((idx + 1) / len(chunks)) * 100)
            progress_bar.progress(
                progress, text=f"üì¶ Ÿæÿ±ÿØÿßÿ≤ÿ¥ {idx + 1} ÿßÿ≤ {len(chunks)} ÿ®ÿÆÿ¥"
            )

        progress_bar.empty()
        end_total = time.time()
        st.info(f"üïí ⁄©ŸÑ ÿ≤ŸÖÿßŸÜ Ÿæÿ±ÿØÿßÿ≤ÿ¥: {end_total - start_total:.2f} ÿ´ÿßŸÜ€åŸá")
        print(f"‚úÖ All chunks processed in {end_total - start_total:.2f} seconds")

        total_minutes = total_seconds / 60
        cost_estimate = total_minutes * 0.006
        st.info(f"üí∞ Ÿáÿ≤€åŸÜŸá ÿ™ŸÇÿ±€åÿ®€å Ÿæÿ±ÿØÿßÿ≤ÿ¥: ${cost_estimate:.4f} (ÿ®Ÿá ŸÜÿ±ÿÆ $0.006/min)")
        print(f"üí∞ Estimated cost: ${cost_estimate:.4f}")

        st.subheader("üìÑ ŸÖÿ™ŸÜ ⁄©ÿßŸÖŸÑ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨‚Äåÿ¥ÿØŸá:")
        st.text_area("Transcript", full_transcript, height=200)
        print("üü¢ Transcript displayed")

        # Copy transcript button
        st.code(full_transcript, language=None)
        st.caption("ÿ®ÿ±ÿß€å ⁄©Ÿæ€å ⁄©ÿ±ÿØŸÜ ŸÖÿ™ŸÜ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨‚Äåÿ¥ÿØŸáÿå ÿ±Ÿà€å ÿ¢€å⁄©ŸàŸÜ üìã ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.")

        st.download_button(
            label="üì• ÿØÿßŸÜŸÑŸàÿØ ŸÖÿ™ŸÜ ⁄©ÿßŸÖŸÑ",
            data=full_transcript,
            file_name="transcript.txt",
            mime="text/plain",
        )
        print("üü¢ Transcript download button rendered")

        with st.spinner("üß† ÿØÿ± ÿ≠ÿßŸÑ ÿÆŸÑÿßÿµŸá‚Äåÿ≥ÿßÿ≤€å ŸÖÿ™ŸÜ..."):
            print("üü° Summarizing transcript...")

            summary = summarize_text(full_transcript, gpt_prompt)
        print("‚úÖ Summary generated")

        # Save log for this request
        save_request_log(
            original_file_path=temp_path,
            original_file_name=uploaded_file.name,
            transcribe_prompt=transcribe_prompt,
            transcript=full_transcript,
            gpt_prompt=gpt_prompt,
            summary=summary,
            extra_data={
                "cost_estimate": cost_estimate,
                "processing_time": end_total - start_total,
                "audio_length": format_time(len(audio)),
            },
        )

        st.subheader("üìù ÿÆŸÑÿßÿµŸá ŸÖÿ™ŸÜ:")
        st.success(summary)
        print("üü¢ Summary displayed")

        # Copy summary button
        st.code(summary, language=None)
        st.caption("ÿ®ÿ±ÿß€å ⁄©Ÿæ€å ⁄©ÿ±ÿØŸÜ ÿÆŸÑÿßÿµŸáÿå ÿ±Ÿà€å ÿ¢€å⁄©ŸàŸÜ üìã ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.")

        st.download_button(
            label="üì• ÿØÿßŸÜŸÑŸàÿØ ÿÆŸÑÿßÿµŸá",
            data=summary,
            file_name="summary.txt",
            mime="text/plain",
        )
        print("üü¢ Summary download button rendered")

        os.remove(temp_path)
        print("üßΩ Temporary files cleaned up")

    print("‚úÖ App ready for next action")


if __name__ == "__main__":
    main()
